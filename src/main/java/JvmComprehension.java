//ClassLoader подгружает System классы (на уровне Bootstrap ClassLoader и JvmComprehension (на уровне Application ClassLoader), происходит связывание и инициализация
//статических инициализаторов и полей (например out типа PrintStream у System, у JvmComprehension статических полей и инициализаторов нет). Классы загружаются в Metaspace.
public class JvmComprehension {
    // В момент вызова метода main() в стеке появляется фрейм, соответствующий области видимости метода main(). Создается объект массива String[], в стеке создается ссылка на него (args).
    public static void main(String[] args) {
        //1 Значимая переменная i со значением 1 помещается в стек во фрейме main.
        int i = 1;                      // 1
        //2 Создается объект класса Object, в хипе под него выделяется область памяти. Ссылочная переменная "о" на объект в хипе помещается в стеке фрейм main().
        Object o = new Object();        // 2
        //3 Создается объект класса Integer (обёртка примитивного int, является ссылочной) со значением поля value 2, в хипе под него выделяется область памяти.
        //Ссылочная переменная ii на объект в хипе помещается в стеке фрейм main().
        Integer ii = 2;                 // 3
        //4 В момент вызовы метода printAll в стеке появляется фрейм. В фрейме printAll(): создается ссылочная переменная "o" на  ранее созданный объект Object(2),
        // создается новая значимая переменная i и помещается в стек, ей передается значение ранее созданной переменной i(1). Создается новая ссылочная переменная ii в
        // стеке на объект Integer(3) в хипе.
        printAll(o, i, ii);             // 4
        //7 Фрейм метода printAll выходит из стека, создается новый фрейм для метода println, в хипе создается объект String для литерала "finished", в фрейме создается
        //ссылочная переменная на этот объект. Метод выводит String в консоль. Фрейм метода выводится из стека.
        System.out.println("finished"); // 7
    }
    //По завершению метода main() он также выводится из стека, сборщик мусора скорее всего не срабатывает, т.к. такой программой хип не заполняется для его срабатывания. Память хипа освобождается.
    //Однако при срабатывании сборщика мусора были бы удалены из хипа объект Integer из (5), а также все объекты String из (6).

    private static void printAll(Object o, int i, Integer ii) {
        //5 Создается новый объект Integer со значением поля value 700, а также ссылочная переменная uselessVar, указывающая на этот объект, в стеке во фрейме printAll.
        Integer uselessVar = 700;                   // 5
        //6 Происходит вызов методов toString на объектах по ссылкам o, i и ii, создаются соответствующие фреймы, результаты возвращаемые этими методами (объекты String в хипе) передаются
        //как аргументы в метод println (при этом в хипе создается объект StringBuilder и вызывается метод append на каждый из стрингов, т.е. создаются соответствующие фреймы).
        //на результате методов append вызывается конечный метод toString, создается соответствующий фрейм, по итогу появляется объект String в хипе - результат конкатенации.
        //При вызове метода println создается новый фрейм в стеке, с новой ссылочной переменной, указывающей на объект стринг (результат конкатенации). Метод выводит String в консоль.
        System.out.println(o.toString() + i + ii);  // 6
    }
}


